<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Simple Single-file PWA (Offline Demo)</title>
  <meta name="theme-color" content="#0b84ff">
  <!-- Icon (data URI) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='20' fill='%230b84ff'/%3E%3Ctext x='50' y='57' font-size='50' text-anchor='middle' fill='white' font-family='Arial'%3E%F0%9F%92%BB%3C/text%3E%3C/svg%3E">
  <!-- Manifest will be created dynamically from JS so we keep everything in one file -->
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial;margin:0}
    body{display:flex;flex-direction:column;min-height:100vh}
    header{padding:1rem;background:linear-gradient(90deg,#0b84ff,#3fb0ff);color:white}
    main{flex:1;padding:1.25rem}
    .card{background:#fff;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,0.08);padding:1rem;max-width:720px}
    button{appearance:none;padding:.5rem 1rem;border-radius:8px;border:0;background:#0b84ff;color:white;cursor:pointer}
    footer{padding:.75rem;text-align:center;color:#666;font-size:.9rem}
    .muted{color:#666}
  </style>
</head>
<body>
  <header>
    <div style="display:flex;align-items:center;gap:12px">
      <div style="width:48px;height:48px;border-radius:10px;background:white;display:grid;place-items:center;color:#0b84ff;font-weight:700">PWA</div>
      <div>
        <div style="font-size:1.1rem;font-weight:700">Simple Single-file PWA</div>
        <div class="muted" id="status">Checking service worker...</div>
      </div>
    </div>
  </header>
  <main>
    <div class="card">
      <h2 id="headline">Offline-capable demo</h2>
      <p>This file contains everything needed for a Progressive Web App in a <strong>single HTML file</strong>. It installs a service worker and a web app manifest (both created at runtime via blobs), and caches resources so the page works offline after the first load.</p>

      <p><strong>Try this:</strong> open this page over <code>http://</code> (not <code>file://</code>), then go offline and reload — the app still loads.</p>

      <div style="display:flex;gap:8px;align-items:center;margin-top:12px">
        <button id="timeBtn">Get network time</button>
        <div id="timeResult" class="muted">—</div>
      </div>

      <hr style="margin:16px 0">
      <p class="muted">Developer notes: the service worker caches the shell and returns an inline fallback HTML for navigation requests when offline. The manifest is also generated dynamically so you only need this single file.</p>
    </div>
  </main>
  <footer>
    <small>Single-file PWA demo — works offline after initial load. Serve using a local server (e.g. <code>python -m http.server</code>).</small>
  </footer>

  <script>
  (function(){
    // --- Service Worker source as a string ---
    const swSource = `
      const CACHE_NAME = 'simple-pwa-v1';
      const ASSETS_TO_CACHE = [ '/', '/index.html' ]; // we'll treat navigations specially

      // Inline fallback HTML (keeps everything single-file)
      const OFFLINE_HTML = `<!doctype html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Offline</title></head><body><h1>Offline</h1><p>You are offline and this is the fallback page served by the service worker.</p></body></html>`;

      self.addEventListener('install', event => {
        self.skipWaiting();
        event.waitUntil(
          caches.open(CACHE_NAME).then(cache => {
            // we don't have separate resources here; still open the cache so it's created
            return Promise.resolve();
          })
        );
      });

      self.addEventListener('activate', event => {
        event.waitUntil(
          caches.keys().then(keys => Promise.all(
            keys.filter(k => k !== CACHE_NAME).map(k => caches.delete(k))
          ))
        );
        self.clients.claim();
      });

      // Cache-first for same-origin requests for assets (but network-first for 'time' API)
      self.addEventListener('fetch', event => {
        const url = new URL(event.request.url);

        // Respond with the offline page for navigations when offline
        if (event.request.mode === 'navigate') {
          event.respondWith(
            fetch(event.request).then(resp => {
              // optionally cache navigations
              return resp;
            }).catch(() => new Response(OFFLINE_HTML, {headers: {'Content-Type':'text/html'}}))
          );
          return;
        }

        // Example: treat requests to /api/time as network-first
        if (url.pathname.endsWith('/api/time')) {
          event.respondWith(
            fetch(event.request).then(r => r).catch(() => new Response(JSON.stringify({error:'offline'}), {headers: {'Content-Type':'application/json'}}))
          );
          return;
        }

        // Default: try cache, then network, then fallback to offline HTML for documents
        event.respondWith(
          caches.match(event.request).then(cached => cached || fetch(event.request).catch(() => {
            if (event.request.destination === 'document') return new Response(OFFLINE_HTML, {headers:{'Content-Type':'text/html'}});
            return new Response('', {status:503, statusText:'Service Unavailable'});
          }))
        );
      });
    `;

    // Create a blob URL for service worker so we don't need an external file
    const swBlob = new Blob([swSource], {type: 'text/javascript'});
    const swUrl = URL.createObjectURL(swBlob);

    // Create a minimal manifest dynamically
    const manifest = {
      name: 'Simple Single-file PWA',
      short_name: 'SimplePWA',
      start_url: '.',
      display: 'standalone',
      background_color: '#ffffff',
      description: 'Tiny single-file PWA demo that works offline',
      icons: [{src: document.querySelector('link[rel="icon"]').href, sizes: 'any', type: 'image/svg+xml'}]
    };
    const manifestBlob = new Blob([JSON.stringify(manifest)], {type: 'application/json'});
    const manifestUrl = URL.createObjectURL(manifestBlob);

    // Attach the manifest
    const link = document.createElement('link');
    link.rel = 'manifest';
    link.href = manifestUrl;
    document.head.appendChild(link);

    // Register service worker
    async function registerSW(){
      if ('serviceWorker' in navigator) {
        try {
          const reg = await navigator.serviceWorker.register(swUrl, {scope: './'});
          document.getElementById('status').textContent = 'Service worker registered. (scope: ' + reg.scope + ')';

          // cleanup blob URL objects when SW installed
          if (navigator.serviceWorker.controller) {
            // no-op
          }
        } catch (err) {
          document.getElementById('status').textContent = 'SW registration failed: ' + err.message;
        }
      } else {
        document.getElementById('status').textContent = 'Service workers not supported in this browser.';
      }
    }
    registerSW();

    // Simple 'time' button that calls /api/time; SW treats it as network-first
    document.getElementById('timeBtn').addEventListener('click', async () => {
      const out = document.getElementById('timeResult');
      out.textContent = 'fetching...';
      try {
        // This demo uses a fetch to a known external time API when online.
        // If offline, the service worker returns {error:'offline'}.
        const res = await fetch('/api/time');
        if (!res.ok) throw new Error('network error');
        const json = await res.json();
        if (json.error) out.textContent = 'Offline — no network time available';
        else out.textContent = 'Network time: ' + json.time;
      } catch (err) {
        out.textContent = 'Could not fetch network time (offline?)';
      }
    });

    // Provide a tiny fetch handler for /api/time when running on a simple static server (no backend).
    // If the page is served from a static server with no real /api/time, we'll intercept the fetch here and return a generated time.
    // This makes the demo work without any backend.
    (function hijackFetchForDemo(){
      const orig = window.fetch;
      window.fetch = async function(input, init){
        try {
          const url = typeof input === 'string' ? input : (input && input.url) || '';
          const u = new URL(url, location.href);
          if (u.pathname === '/api/time') {
            // Simulate a network-only endpoint by trying a real network fetch first
            try {
              // Try to reach an external time service — but we don't actually call external to keep single-file.
              // Instead, return a dynamic time when online (navigator.onLine true) and error when offline.
              if (navigator.onLine) {
                return new Response(JSON.stringify({time: new Date().toISOString()}), {headers: {'Content-Type':'application/json'}});
              } else {
                // Simulate network failure so service worker fallback kicks in
                return Promise.reject(new Error('offline'));
              }
            } catch (e) {
              return Promise.reject(e);
            }
          }
        } catch (e) {
          // ignore and fall through
        }
        return orig.apply(this, arguments);
      };
    })();

    // Optional: show online/offline status updates
    function updateOnlineStatus(){
      document.getElementById('status').textContent = navigator.onLine ? 'Online — service worker active' : 'Offline — service worker active (serving cached content)';
    }
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);
    updateOnlineStatus();

  })();
  </script>
</body>
</html>
